# Состав проекта

Ниже в таблице описаны разделы и файлы проекта.

| Папка    | Файл                    | Описание                                                                                                |
|----------|-------------------------|---------------------------------------------------------------------------------------------------------|
| /lesson1 | lesson1-introduction.py | Урок 1 - Домашнее задание вводного занятия                                                              |
| /lesson1 | lesson1-encodings.py    | Урок 1 - Домашнее задание по кодировкам                                                                 |
| /lesson2 | lesson2.py              | Урок 2 - Домашнее задание                                                                               |
| /lesson2 | main_data.csv           | Урок 2 - вывод программы в формате CSV                                                                  |
| /lesson2 | main_data.json          | Урок 2 - вывод программы в формате JSON                                                                 |
| /lesson2 | main_data.yaml          | Урок 2 - вывод программы в формате YAML                                                                 |
| /lesson6 | logdecorator.py         | Урок 6 - декоратор @log                                                                                 |
| /lesson9 | lesson9.py              | Урок 9 - пинг с использованием subprocess и tabulate                                                    |
| /        | client.py               | Уроки 3-7 - скрипт клиента                                                                              |
| /        | client_log_config.py    | Урок 5 - файл с кодом конфигурирования системы логирования для клиента                                  |
| /        | client_settings.py      | Уроки 3-5 - константы клиента                                                                           |
| /        | client_threads.py       | Урок 8 - скрипт клиента с использованием модуля threading                                               |
| /        | jim.py                  | Уроки 3-4 - реализация протокола JIM                                                                    |
| /        | requirements.txt        | Файл зависимостей (dependencies) проекта                                                                |
| /        | server.py               | Уроки 3-5 - скрипт однопользовательского сервера (только сообщение presence)                            |
| /        | server_log_config.py    | Урок 5 - файл с кодом конфигурирования системы логирования для сервера                                  |
| /        | server_select.py        | Урок 7 - скрипт многопользовательского сервера с использованием select()                                |
| /        | server_settings.py      | Уроки 3-5 - константы сервера                                                                           |
| /        | start_chat.py           | Урок 9 - запуск сервера и указанного количества клиентов (по умолчанию - 2) с использованием subprocess |
| /test    | test_jim.py             | Урок 4 - тесты к модулю реализации протокола JIM jim.py                                                 |

## Запуск проекта

Сервер запускается командой (опция _--help_ - справка по аргументам командной строки):

- Однопользовательский сервер с поддержкой только сообщения presence:


    python server.py [--help]

- Многопользовательский однопоточный сервер с использованием select():


    python server_select.py [--help]

Клиент запускается командой (опция _--help_ - справка по аргументам командной строки):

- Однопоточный клиент с использованием select():


    python client.py [--help]

- Многопоточный клиент с использованием модуля threading:


    python client_threads.py [--help]
 
## Запуск тестов

Тесты запускаются командой в папке /test:

    python test_jim.py

# Зависимости (dependencies)

В корне проекта в файле requirements.txt содержится список зависимостей проекта - 
библиотек, не входящих в стандартный комплект поставки Python. 
Ниже в таблице представлена детализация. 

| Раздел   | Зависимости |
|----------|-------------|
| /lesson2 | pyyaml      |
| /lesson9 | tabulate    |

# Комментарии к ДЗ

## Урок 1

Формулировка задания вводного урока не вполне понятна в части: "Каждый из вариантов реализуйте в виде класса и в виде функций с использованием оператора yield."

Фактически в англоязычной документации Python по приведенным в задании ссылкам описаны: 
- создание итератора на базе класса и
- создание генератора на базе функции,

что и было сделано в домашнем задании.

## Урок 2

Задание поставлено невнятно. 

Так как внятная логика просматривается только в задании 1, все три задания реализованы аналогично. 
Детали реализации и перечень выявленных невнятных требований ДЗ представлены ниже.

В п.1 а) main_data сначала называется списком, потом - файлом. Неясно, что значит - «для каждого файла». 
Реализация: в функции get_data() создается словарь, ключами которого являются названия параметров, 
а значениями - списки значений параметров из указанных в заданиях файлов.

В п.1 б) непонятно, что значит - «ссылка на CSV файл». 
Также не соответствует названию функции write_to_csv() задача ЧТЕНИЯ из файлов. 
Реализация: в функцию write_to_csv() передается имя целевого файла CSV. 
Чтение данных из исходных файлов происходит вне функции - в основной программе. 
В функцию write_to_csv() передаются заранее считанные данные.

В п.2 непонятно, что значит - «скрипт, автоматизирующий его заполнение данными»: 
нужно запрашивать их у пользователя, или читать откуда-либо, или заполнять случайными данными? 
В п.2 б) непонятно, что значит - «с передачей в нее значений каждого параметра»: 
нужно проверять, что будет, если передать значения каждого из параметров в отдельности? 
Реализация: функция write_to_json(), аналогично write_to_csv(), записывает в формате JSON данные, 
ранее считанные из исходных файлов, данные сгруппированы по строкам.

В п.3 а) структура данных вообще не понятна: 
«первому ключу соответствует список» чего? 
«второму — целое число» - какое, произвольное? 
«третьему — вложенный словарь, где значение каждого ключа — это целое число с юникод-символом, 
отсутствующим в кодировке ASCII (например, €)» - то есть ключом является число и символ? 
А какое значение хранить по этому ключу? 
В п.3 с) непонятно, как и зачем проверять совпадение считанных данных 
и почему их не надо проверять после записи в файлы других форматов. 
Реализация: функция write_to_yaml(), аналогично write_to_csv(), записывает в формате YAML данные, 
ранее считанные из исходных файлов, данные сгруппированы по столбцам.

## Урок 4

Клиент и сервер к моменту написания тестов представляют собой линейный код, который не имеет смысла тестировать.
Тесты написаны к модулю реализации протокола JIM jim.py (см. папку test/). 
Тестируются сообщения (message) и ответы (response), 
в том числе длина сообщения, наличие и адекватность содержимого полей.

## Урок 5

П.1 - В задании требуется сохранить в каталог log программные файлы конфигурирования системы логирования,
при этом нет требования сохранят сами логи в вышеуказанном каталоге. 
Однако, функцией логов программного обеспечения является накопление информации о его работе 
в течение всего цикла эксплуатации ПО, 
и так как объем логов в связи с этим может быть значительным, на практике может быть предусмотрена ротация логов, 
их архивирование, сжатие или периодическое удаление; 
в случае хранения логов вместе с программным кодом существенно увеличивается вероятность того, 
что вышеуказанные операции с логами могут повредить код программы, 
следовательно, логи целесообразно помещать в отдельный каталог.
В связи с вышесказанным, вышеупомянутые программные файлы размещены 
в основном каталоге проекта, вместе с другими программными файлами, 
а файлы логов - в каталоге log.

## Урок 6

П.1 - Непонятно, что значит - "Он [декоратор] сохраняет ее [функции] имя и аргументы": 
что сохраняет, зачем? Задание интерпретировано так, как это реализовано декоратором wraps.  

Задание выполнено в отдельном файле python - /lesson6/logdecorator.py
 
## Урок 7

В клиенте дополнительно к заданию реализован одновременный прием и отправка сообщений.

## Урок 8

Задание сформулировано невнятно.

"На клиентской стороне реализовать прием и отправку сообщений с помощью потоков в P2P-формате 
(обмен сообщениями между двумя пользователями)"
Что имеется в виду? 
- Надо запустить одного клиента, 
а потом ввести его адрес и порт как параметры при запуске другого клиента? Иначе, 
в отсутствии реализации сервера (каталога или иной),
практически невозможно в общем случае найти второго клиента, если не сканировать порты всей сети Интернет.
- Реализовать на сервере справочник адресов клиентов в онлайне, а соединение TCP устанавливать между клиентами, 
минуя сервер?
- Или просто реализовать обмен сообщениями через сервер между клиентами, а не широковещательные сообщения,
как это было реализовано на прошлом уроке?

В реализации пошел по последнему пути.

Работающая реализация - server_select.py и любой из клиентов: 
- client.py - реализация через select()
- client_threads.py - реализация через модуль threading

## Урок 9

Функции реализованы 
Задание, как водится, сформулировано невнятно.

0. Не сказано, какая версия IP рассматривается - v4 или v6. Представлено решение для IPv4.

1. Нигде не сказано, что имена хостов нужно преобразовывать в ip-адреса,  
а функция ip_address() выдаст ошибку при передаче в нее имени хоста, что и видно в реализации.

2. Сказано, что изменяться должен только последний октет каждого адреса, 
но не сказано, что для границ диапазона первые три октета должны совпадать. 
В реализации указывается начальный адрес диапазона и количество адресов для пинга; 
пингуется не более хостов, чем осталось от указанного начального адреса до конца сети, считая, что сеть - /24, 
не включая адрес сети (.0) и широковещательный (broadcast) адрес (.255).

3. Реализовано в соответствии с заданием, с учетом правила DRY.

4. В проекте клиент был реализован изначально дуплексным, в связи с чем задание а) невыполнимо. 

Задание б) выполнено в скрипте start_chat.py, однако, на Mac OS все процессы запускаются в одном окне, 
и соответственно запущенный таким образом набор программ непригоден к обмену сообщениями. 
Решение задачи запуска нескольких скриптов в разных окнах из одного скрипта Python на Mac OS средствами 
рассмотренных на уроке модулей не найдено, реализация этой задачи другими средствами нецелесообразна как
нерелевантная программе обучения.

6. Весь код проекта изначально объектно-ориентированный. 

## Урок 10

1. Метакласс ClientVerifier реализован в файле ClientVerifier.py, его наследует класс Client в файле client.py.
Замечания по реализации, по пунктам:

- Анализируется наличие в коде класса вызовов методов accept и listen. Проверка отреагирует ошибкой на вызов любых
методов, одноименных вышеупомянутым, независимо от класса, их содержащего. 
Так как предметом изучения является функционирование метаклассов, а не анализ байт-кода Python, было принято решение
не тратить время на сколько-нибудь сложный анализатор байт-кода.

- Анализируется наличие в коде класса вызова метода socket (конструктора класса socket библиотеки socket) 
с позиционными параметрами AF_INET и SOCK_STREAM. 
Проверка может некорректно работать с любым другим способом передачи параметров конструктору 
(условия, числовые параметры, переменные на месте параметров),
а также примет за "правильный" конструктор вызов любого другого метода socket с вышеуказанными параметрами. 
Так как предметом изучения является функционирование метаклассов, а не анализ байт-кода Python, было принято решение
не тратить время на сколько-нибудь сложный анализатор байт-кода.

- Проверяется отсутствие атрибута класса, хранящего экземпляр класса socket библиотеки socket.

2. 